ESP32 Exception Stack Backtrace Analyzer for esp-idf
====================================================

This little bash script parses the exception backtrace printed by the ESP32 firmware
and uses GDB to print out the source location of all code addresses.

It is heavily inspired by https://github.com/me-no-dev/EspExceptionDecoder but only uses
bash and xtensa-esp32-elf GDB.

__Install:__ Place the esp32-backtrace script somewhere in your path or use the full pathname to run
it. __You need to edit the `XTENSA_GDB` definition at the top of the script.__

Usage
-----
```
usage:     ./esp32-backtrace <elf file> <backtrace-text>
example:   ./esp32-backtrace build/esp-idf_my_project.elf 0x40015b2f 0x400147d8
 
Will use gdb to attempt to reconcile the backtrace with files and line numbers.
If gdb cannot reconcile an address, it will not output for that step in the backtrace.
```
Example
-------
My program crashed printing on the esp-idf serial monitor in VSCode (idf_monitor.py):
```
assert failed: uxQueueMessagesWaiting queue.c:2095 (xQueue)


Backtrace: 0x4008227e:0x3ffdde50 0x40089d85:0x3ffdde70 0x4009327e:0x3ffdde90 0x4008ada6:0x3ffddfb0 0x400dacaa:0x3ffddfd0 0x40141ed1:0x3ffde340 0x400e0391:0x3ffde3b0 0x400e06dc:0x3ffde3f0
0x4008227e: panic_abort at /Users/my_userid/my_project/components/esp_system/panic.c:402

0x40089d85: esp_system_abort at /Users/my_userid/my_project/components/esp_system/esp_system.c:128

0x4009327e: __assert_func at /Users/my_userid/my_project/esp-idf/components/newlib/assert.c:85

0x4008ada6: uxQueueMessagesWaiting at /Users/my_userid/my_project/esp-idf/components/freertos/queue.c:2095 (discriminator 1)

0x400dacaa: my_func at /Users/my_userid/my_project/main/main.c:1668

etc.
```
The panic in this case prints out as "assert failed:" etc.

The system prints out the Backtrace: line

The backtrace in the serial monitor is actually generated by idf_monitor.py (and shows in yellow).

The problem I needed to solve (that prompted me to fork this) is that my devices are remote, and I have built infrastructure
to persist the key elements of the backtrace during a panic into boot-surviving memory. I can then report that data back
(using websockets) after the reboot. What I store and report is just the list of program counters, so it looks like this:
```
{"reboot_count":1,"last_reboot_cause":4,"backtrace":" 0x400d5cd5 0x400d6998 0x400d5b0f"}
```
or similar.

Hence I want to be able to resolve the backtrace from just hex pc values.

Example Output
--------------

I launch the esp-backtrace as:
`esp32-backtrace build/esp-idf_my_project.elf 0x400d5cd5 0x400d6998 0x400d5b0f`
and the result is:
```
BT-1: 0x400d5cd5 is in uart_tx_char (/Users/my_userid/my_project/esp-idf/components/hal/esp32/include/hal/uart_ll.h:319).
319	    return UART_LL_FIFO_DEF_LEN - HAL_FORCE_READ_U32_REG_FIELD(hw->status, txfifo_cnt);
BT-2: 0x400d6998 is in uart_write (/Users/my_userid/my_project/esp-idf/components/vfs/vfs_uart.c:209).
209	        s_ctx[fd]->tx_func(fd, c);
BT-3: 0x400d5b0f is in console_write (/Users/my_userid/my_project/esp-idf/components/vfs/vfs_console.c:73).
73	    get_vfs_for_index(primary_vfs_index)->vfs.write(vfs_console.fd_primary, data, size);
```
Now this is only partial for the sake of the README, but 
it tells me that the problem happens in a low level library that is sending characters out the UART. It suggests that 'hw' has become 
corrupted and that this is a pointer dereference panic.

I changed the syntax from the original project (that I forked from). It no longer handles the register dump (which I don't have in
in esp-idf nor in my post-reboot reporting) and I removed the option of reading the exception
from stdin. I changed the syntax so the  pc list is provided on the command line. I also changed the format
to not accept the `0x<pc>:0x<sp>` style pasted from the serial monitor - since the idf_monitor already decodes the backtrace, plus
my backtrace is now only a list of pc values.

### Notes:
- The backtrace shows the inner-most frame first (BT-1) and then goes back in history.

Issues
------
- GDB is invoked for each address, which is inefficient. It works ok for me, but it would be more
  elegant to construct a script for GDB and pipe that in so GDB only reads and parses the elf file
  once.
